name: Release Desktop

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  release:
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: macos-latest
            target: universal-apple-darwin
            platform: macOS
          - runner: windows-latest
            target: x86_64-pc-windows-msvc
            platform: Windows

    runs-on: ${{ matrix.runner }}
    timeout-minutes: 90

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout k2 submodule
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.K2_DEPLOY_KEY }}

      - name: Init k2 submodule
        shell: bash
        run: git -c url."git@github.com:".insteadOf="https://github.com/" submodule update --init --recursive

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: k2/go.sum

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macOS' && 'aarch64-apple-darwin,x86_64-apple-darwin' || 'x86_64-pc-windows-msvc' }}

      - name: Cache Rust target directory
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            desktop/src-tauri/target
          key: rust-release-${{ runner.os }}-${{ hashFiles('desktop/src-tauri/Cargo.lock') }}
          restore-keys: |
            rust-release-${{ runner.os }}-

      - name: Install Node dependencies
        run: yarn install --frozen-lockfile --network-timeout 600000 --network-concurrency 4

      - name: Run pre-build (Windows)
        if: matrix.platform == 'Windows'
        run: make pre-build

      - name: Build webapp (Windows)
        if: matrix.platform == 'Windows'
        run: make build-webapp

      # --- macOS: code signing certificate import ---

      - name: Import Apple code signing certificate
        if: matrix.platform == 'macOS'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          echo "$APPLE_CERTIFICATE" | base64 --decode > "$CERTIFICATE_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security import "$CERTIFICATE_PATH" \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db

      # --- macOS: full build via shared script ---

      - name: Build macOS (k2 + tauri + pkg)
        if: matrix.platform == 'macOS'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_INSTALLER_IDENTITY: ${{ secrets.APPLE_INSTALLER_IDENTITY }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: bash scripts/build-macos.sh

      # --- Windows: build k2 + Tauri (NO signing — handled by kaitu-signer service) ---

      - name: Build k2 for Windows
        if: matrix.platform == 'Windows'
        run: make build-k2 TARGET=x86_64-pc-windows-msvc
        env:
          GOARCH: amd64
          GOOS: windows

      - name: Build Tauri for Windows
        if: matrix.platform == 'Windows'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: yarn tauri build --target x86_64-pc-windows-msvc
        working-directory: desktop

      # --- Windows: upload unsigned artifacts → trigger signing service → wait → download signed ---

      - name: Upload unsigned artifacts to S3 signing queue
        if: matrix.platform == 'Windows'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-1
        shell: bash
        run: |
          NSIS_DIR="desktop/src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis"
          RUN_ID="${GITHUB_RUN_ID}"
          S3_PENDING="s3://d0.all7.cc/kaitu/signing/pending/${RUN_ID}/"

          echo "Uploading unsigned artifacts to ${S3_PENDING}"
          aws s3 cp "${NSIS_DIR}/" "${S3_PENDING}" --recursive \
            --exclude "*" \
            --include "*.exe" --include "*.exe.sig"

          # List uploaded files for SQS message
          FILES=$(aws s3 ls "${S3_PENDING}" | awk '{print $4}' | grep '\.exe$' | head -5)
          echo "Uploaded files:"
          echo "${FILES}"

          # Save file list for next step
          echo "${FILES}" > "${RUNNER_TEMP}/signing-files.txt"

      - name: Send SQS signing request
        if: matrix.platform == 'Windows'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-1
          SQS_QUEUE_URL: ${{ secrets.SQS_SIGNING_QUEUE_URL }}
        shell: bash
        run: |
          RUN_ID="${GITHUB_RUN_ID}"
          FILES_JSON=$(cat "${RUNNER_TEMP}/signing-files.txt" | jq -R -s 'split("\n") | map(select(length > 0))')

          MESSAGE=$(jq -n \
            --arg run_id "${RUN_ID}" \
            --arg s3_prefix "kaitu/signing/pending/${RUN_ID}/" \
            --argjson files "${FILES_JSON}" \
            --arg cert_name "Wordgate LLC" \
            --arg timestamp_url "http://timestamp.sectigo.com" \
            --arg completed_prefix "kaitu/signing/completed/${RUN_ID}/" \
            '{run_id: $run_id, s3_prefix: $s3_prefix, files: $files, cert_name: $cert_name, timestamp_url: $timestamp_url, completed_prefix: $completed_prefix}')

          echo "Sending SQS message:"
          echo "${MESSAGE}" | jq .

          aws sqs send-message \
            --queue-url "${SQS_QUEUE_URL}" \
            --message-body "${MESSAGE}"

          echo "SQS message sent for run ${RUN_ID}"

      - name: Wait for signing to complete
        if: matrix.platform == 'Windows'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-1
        shell: bash
        run: |
          bash scripts/ci/wait-for-signing.sh "${GITHUB_RUN_ID}" "d0.all7.cc" 600

      - name: Download signed artifacts
        if: matrix.platform == 'Windows'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-1
        shell: bash
        run: |
          RUN_ID="${GITHUB_RUN_ID}"
          S3_COMPLETED="s3://d0.all7.cc/kaitu/signing/completed/${RUN_ID}/"
          LOCAL_SIGNED="signed-artifacts/"
          mkdir -p "${LOCAL_SIGNED}"

          echo "Downloading signed artifacts from ${S3_COMPLETED}"
          aws s3 cp "${S3_COMPLETED}" "${LOCAL_SIGNED}" --recursive \
            --exclude "status.json"

          echo "Signed artifacts:"
          ls -la "${LOCAL_SIGNED}"

      # --- Upload artifacts to S3 ---

      - name: Upload macOS to S3
        if: matrix.platform == 'macOS'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-1
        run: |
          VERSION=$(node -p "require('./package.json').version")
          S3_BASE="s3://d0.all7.cc/kaitu/desktop/${VERSION}"
          aws s3 cp release/${VERSION}/ "${S3_BASE}/" --recursive

      - name: Upload Windows to S3
        if: matrix.platform == 'Windows'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-northeast-1
        shell: bash
        run: |
          VERSION=$(node -p "require('./package.json').version")
          S3_BASE="s3://d0.all7.cc/kaitu/desktop/${VERSION}"

          # Upload signed .exe files
          aws s3 cp signed-artifacts/ "${S3_BASE}/" --recursive \
            --exclude "*" \
            --include "*.exe"

          # Upload .exe.sig from original build (Tauri update signature, not code signature)
          NSIS_DIR="desktop/src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis"
          aws s3 cp "${NSIS_DIR}/" "${S3_BASE}/" --recursive \
            --exclude "*" \
            --include "*.exe.sig"

      # --- Cleanup ---

      - name: Clean up keychain
        if: matrix.platform == 'macOS' && always()
        run: security delete-keychain "$RUNNER_TEMP/app-signing.keychain-db" || true

      # --- Notifications ---

      - name: Notify Slack on build success
        if: success()
        shell: bash
        run: |
          VERSION=$(node -p "require('./package.json').version")
          ./scripts/ci/notify-slack.sh deploy-success \
            --version "${VERSION}" \
            --platforms "${{ matrix.platform }}"
        env:
          SLACK_WEBHOOK_RELEASE: ${{ secrets.SLACK_WEBHOOK_RELEASE }}

      - name: Notify Slack on build failure
        if: failure()
        shell: bash
        run: |
          ./scripts/ci/notify-slack.sh build-failure \
            --platform "${{ matrix.platform }}" \
            --error "Release build failed on ${{ matrix.platform }}. Check workflow run for details."
        env:
          SLACK_WEBHOOK_ALERT: ${{ secrets.SLACK_WEBHOOK_ALERT }}
