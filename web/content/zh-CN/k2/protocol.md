---
title: 拥塞控制算法 k2arc
date: 2026-02-22
summary: "k2arc 自适应速率控制算法深度解析：效用函数梯度上升、自适应丢包惩罚系数、三阶段状态机、与标准 PCC 的参数差异，及 k2v5 协议技术要素。"
section: technical
order: 5
draft: false
---

# 拥塞控制算法 k2arc

k2arc（Adaptive Rate Control）是 k2 自研的拥塞控制算法，专为高审查、高丢包网络环境设计。它基于 PCC Vivace 框架，通过**效用函数的梯度上升**自动寻找最优发送速率——无需用户手动配置带宽参数。k2arc 的核心创新是**自适应丢包惩罚系数**，使算法能"看穿"审查性丢包，在 GFW 等高丢包环境中维持远高于 Cubic、BBR 等传统算法的吞吐量。

本文所有参数值直接来自 k2 源码实现。如果您只需要快速使用 k2，请参阅 [1 分钟快速开始](/k2/quickstart)。

## 为什么需要 k2arc

在 GFW 等高审查网络环境中，传统拥塞控制算法面临根本性挑战：

| 算法 | 丢包响应 | 在审查网络中的表现 |
|------|---------|-----------------|
| **Cubic/Reno** | 大幅降速（乘法减少） | 将审查丢包误判为拥塞，5% 丢包率下吞吐量下降 75%+ |
| **BBR** | 基于带宽估计 | 持续丢包干扰带宽探测模型，严重低估可用带宽 |
| **Brutal** | 完全忽略 | 不区分丢包类型，固定速率发送，高丢包下触发重传风暴 |
| **k2arc** | 自适应区分 | 自动识别非拥塞性丢包，维持接近链路容量的有效吞吐 |

GFW 对被检测到的代理连接实施约 **26% 的概率性丢包**（USENIX Security 2023 实测数据）。这个丢包率对传统算法是致命的——Cubic 在此条件下吞吐量不足理论值的 10%。k2arc 的自适应丢包惩罚使其能在 26% 甚至 50% 丢包率下维持有效传输。

## 效用函数——k2arc 的优化目标

k2arc 的核心是一个三项效用函数。每个**监测区间**（Monitor Interval, MI）结束时，算法计算当前效用值：

```
U = Throughput - α × LossRate × Throughput - β × ΔRtt
```

| 分量 | 公式 | 系数默认值 | 作用 |
|------|------|----------|------|
| **吞吐激励** | Throughput (Mbps) | — | 激励提高发送速率 |
| **丢包惩罚** | α × LossRate × Throughput | α = 0.5（GFW 模式） | 抑制因丢包导致的无效传输 |
| **延迟惩罚** | β × ΔRtt | β = 0.1 | 防止 bufferbloat（ΔRtt = 平均RTT − 最小RTT，毫秒） |

算法通过**梯度上升**（gradient ascent）持续最大化 U 值：提高发送速率后如果 U 增大，继续提高；如果 U 减小，降低速率并反向探测。效用值被钳位到最低 -10.0，防止极端负值导致算法不稳定。

### 吞吐量计算

```
Throughput = (BytesAcked × 8) / Duration  (bps)
```

吞吐量基于**已确认字节**而非已发送字节，确保效用函数反映实际有效传输而非包含重传在内的总发送量。

### 丢包率计算

```
LossRate = BytesLost / BytesSent  (0.0 ~ 1.0)
```

### 延迟差计算

```
ΔRtt = max(AvgRtt - MinRtt, 0)  (毫秒)
```

β = 0.1 意味着延迟惩罚权重远低于吞吐激励。这是有意的设计选择——隧道场景下吞吐量优先于延迟控制，但 β 项仍能在路由器缓冲区开始积压时提供有效的 bufferbloat 抑制信号。

---

## 自适应丢包惩罚——k2arc 的核心创新

k2arc 与标准 PCC 最关键的区别在于**丢包惩罚系数 α 是可动态调整的**，而非固定值。k2arc 提供三种 α 策略，适应不同网络环境：

### 标准模式（α = 10.0）

```
适用：低丢包率的优质网络
行为：对丢包高度敏感，积极避让，与其他流量公平共存
```

标准模式下，1% 的丢包率就会使效用函数产生显著的负向压力，驱动算法降低发送速率。适合数据中心内部、同城链路等低丢包环境。

### GFW 模式（α = 0.5，默认启用）

GFW 模式将丢包惩罚系数降至标准值的 **1/20**，使算法在面对审查性丢包时几乎不降速。

```
效用对比（100 Mbps 吞吐，20% 丢包）：

标准模式 α=10.0：
  U = 100 - 10.0 × 0.2 × 100 - β×ΔRtt = -100 - β×ΔRtt
  → 效用深度负值，算法大幅降速

GFW 模式 α=0.5：
  U = 100 - 0.5 × 0.2 × 100 - β×ΔRtt = 90 - β×ΔRtt
  → 效用仍为高正值，算法维持当前速率
```

**为什么 GFW 模式是安全的**：在审查网络中，防火墙主动丢弃数据包并非真正的网络拥塞——降速不会减少丢包率，只会降低有效吞吐量。α = 0.5 使 k2arc 能"看穿"审查丢包，维持接近链路容量的发送速率。

### 自适应模式（α 自动调节）

自适应模式根据观测到的丢包率历史自动调整 α 值，无需预设网络类型。

**计算公式**：

```
α_computed = 10.0 / (1 + 50.0 × avg_loss_rate)
```

**EWMA 平滑**（防止震荡）：

```
α_new = α_old × 0.7 + α_computed × 0.3
```

**范围钳位**：α ∈ [0.1, 10.0]

| 观测丢包率 | 计算 α 值 | 行为特征 |
|-----------|----------|---------|
| 0% | 10.0 | 高度敏感，积极避让（优质网络） |
| 2% | 5.0 | 较高敏感 |
| 5% | 2.86 | 中等容忍 |
| 10% | 1.67 | 较高容忍 |
| 20% | 0.91 | 高度容忍（审查网络） |
| 30% | 0.63 | 极度容忍（极端环境） |

自适应模式维护最近 **4 个 MI** 的丢包率滑动窗口，取均值代入公式。初始 α 值为 **2.0**（中间值）。当网络从正常变为审查状态时，α 会在几个 MI 内自动从高值下降到 1.0 以下。

---

## 三阶段状态机

k2arc 运行时在三个阶段间切换：

```
┌─────────────────────────────────────────────────────────────────┐
│  阶段一：慢启动（Slow Start）                                      │
│                                                                 │
│  速率每个 MI 增长 2.5×                                             │
│  初始速率 = maxRate × 30%                                         │
│  退出条件：效用值降至前值的 95% 以下                                   │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  阶段二：决策（Decision）                                          │
│                                                                 │
│  计算效用梯度 = 当前效用 − 上一次效用                                  │
│  梯度 > 0 → UtilityIncreases++ (连续提升计数)                       │
│  梯度 ≤ 0 → UtilityDecreases++ (连续下降计数)                       │
│                                                                 │
│  连续 ≥2 次提升 → 方向确认为 +ε                                     │
│  连续 ≥2 次下降 → 方向确认为 −ε                                     │
│  否则 → 交替探测 ±ε（按 MI ID 奇偶决定方向）                          │
└───────────────────────┬─────────────────────────────────────────┘
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  阶段三：速率调整（Rate Adjusting）                                  │
│                                                                 │
│  newRate = currentRate + adjustment                              │
│  adjustment = ±currentRate × ε (ε = 15%)                        │
│  EWMA 平滑：finalRate = old × 0.1 + new × 0.9                    │
│                                                                 │
│  每 10 个 MI → 主动向上探测 20%（速率恢复机制）                        │
└─────────────────────────────────────────────────────────────────┘
```

### 慢启动

慢启动阶段以 **2.5 倍 / MI** 的增长率快速逼近可用带宽。初始速率为配置最大速率的 30%（默认 500 Mbps × 30% = 150 Mbps）。

退出条件为效用值降至前一次效用的 **95%** 以下，即检测到效用函数的增长趋势放缓。这比标准 PCC 的 2.0 倍增长更激进（+25%），使 k2arc 能在 **2-3 个 MI** 内快速逼近可用带宽上限。

### 决策与梯度计算

决策阶段是 k2arc 的智能核心。算法通过交替探测高/低速率（±ε），观察效用函数的变化方向：

- **连续 ≥2 次效用提升**：确认当前方向正确，继续沿此方向调整
- **连续 ≥2 次效用下降**：反转方向，向反方向探测
- **不确定状态**：按 MI ID 奇偶交替探测 ±ε，收集更多数据

### 速率调整与 EWMA 平滑

新速率通过 EWMA 平滑避免剧烈波动：

```
finalRate = currentRate × 0.1 + newRate × 0.9
```

**90% 新值权重**意味着 k2arc 对速率变化的响应非常快——新速率在 1 个 MI 内就有 90% 的影响力。这比标准 PCC 的 70% 权重更为激进，在高噪声网络中能更快跟踪带宽变化。

速率始终被钳位到 [最小速率, 最大速率] 范围内。下载方向最小速率为 30 Mbps（上传方向为 10 Mbps），最大速率默认 500 Mbps。

### 速率恢复探测

k2arc 不会在降速后被动等待。**每 10 个 MI**，算法主动向上探测 **20%**：

```
probeRate = currentRate × 1.2
```

探测后重置 UtilityIncreases/Decreases 计数器，给新速率公平的评估机会。

```
当前速率 100 Mbps，因丢包降至 60 Mbps：
  第 10 个 MI：探测 72 Mbps (+20%)
  第 20 个 MI：探测 86 Mbps (+20%)
  第 30 个 MI：探测 103 Mbps（若网络已恢复）
```

此机制使 k2arc 能在 GFW "放松"审查后快速恢复到全速，而非锁定在之前的降速水平。

---

## 监测区间（Monitor Interval）

MI 是 k2arc 的基本观测单位。每个 MI 记录一段时间内的传输统计数据，MI 结束时触发效用计算和速率调整。

### MI 记录的数据

| 字段 | 说明 |
|------|------|
| TargetRate | 该 MI 的目标发送速率 (bps) |
| BytesSent / BytesAcked / BytesLost | 发送、确认、丢失字节数 |
| RTTSamples | RTT 采样数组（用于计算 AvgRtt 和 MinRtt） |
| PacketsSent / PacketsAcked | 包计数 |
| IsAppLimited | 应用受限标记 |
| Duration | MI 持续时间 |

### MI 完成条件

k2arc 使用三级 MI 完成策略，适应从高速到低速的各种场景：

| 完成条件 | 触发规则 | 适用场景 |
|---------|---------|---------|
| **标准完成** | PacketsAcked ≥ 10 且有 RTT 采样 | 正常传输 |
| **宽松完成** | PacketsAcked ≥ 3 且有 RTT 采样，且持续 ≥ 30 秒 | 低速率场景 |
| **超时完成** | 持续时间 ≥ 60 秒 | 极端丢包/超低速 |

标准 PCC 仅有标准完成条件。三级策略确保 k2arc 在各种网络条件下都能正常运作——即使在极端丢包导致几乎没有 ACK 返回的场景中，超时机制也能保证算法不会卡死。

### 应用受限检测

当应用层没有足够数据发送时，传输统计不能反映真实网络能力：

```
判定条件：actualBytesSent < expectedBytes × 0.5
其中：expectedBytes = targetRate × duration / 8
```

当实际发送量低于目标速率的 **50%** 时，该 MI 被标记为"应用受限"，**跳过效用计算**。这避免了因应用空闲（如用户暂停下载）导致的虚假速率下降。

---

## 发包节奏控制（Pacing）

k2arc 将目标发送速率转换为拥塞窗口（cwnd）来控制发包节奏：

```
cwnd = (rate_bps / 8) × rtt_seconds × 2.0
```

| 参数 | 值 | 说明 |
|------|-----|------|
| BDP 乘数 | 2.0× | 与 BBR 的 cwnd_gain 匹配，为突发 ACK 模式提供缓冲裕量 |
| 最小 cwnd | 14,720 bytes | 10 个 MTU 大小的数据包（10 × 1,472） |
| 最大 cwnd | 1 GB | 防止内存溢出 |

**发包预算机制**：

```
budgetIncrease = (currentRate / 8) × elapsedTime
pacingBudget += budgetIncrease
pacingBudget = min(pacingBudget, cwnd)  // 防止突发
```

pacing 确保数据包均匀分布在时间轴上，避免突发流量造成队列堆积。预算上限被钳位到 cwnd，防止因计时器偏差导致的瞬间突发。

---

## k2arc vs 标准 PCC：参数对比

k2arc 基于 PCC Vivace 框架，但针对审查网络环境做了大量参数调优。以下是与标准 PCC 实现的精确差异：

| 参数 | k2arc 值 | 标准 PCC | 差异 | 设计理由 |
|------|---------|---------|------|---------|
| 慢启动增长 | **2.5×** / MI | 2.0× | +25% | 更快逼近可用带宽 |
| 探测步长 ε | **15%** | 5% | 3× | 高噪声网络中更快发现最优点 |
| 速率 EWMA | **90%** 新值 | 70% 新值 | +20% | 更快响应网络变化 |
| 探测周期 | **每 10 MI** | 每 20 MI | 2× 更频繁 | 更快恢复降速后的速率 |
| 探测增幅 | **20%** | 10% | 2× | 更积极地探索更高速率 |
| BDP 乘数 | **2.0×** | ~1.0× | 2× | 为突发 ACK 模式提供缓冲裕量 |
| MI 完成策略 | **标准 + 宽松 + 超时** | 仅标准 | +2 | 适应低速和极端丢包场景 |
| 丢包惩罚 α | **0.5**（GFW 默认） | 10.0（固定） | 1/20 | 容忍审查性丢包 |
| 延迟惩罚 β | **0.1** | ~1.0 | 1/10 | 隧道场景吞吐量优先 |

**总结**：k2arc 在所有维度上都比标准 PCC 更激进——更快的起步速度、更大的探测步长、更高的响应灵敏度、更频繁的速率恢复。这些参数组合使其在高噪声、高丢包的审查网络中表现远优于保守的标准实现。

---

## 协议技术要素

以下是 k2v5 协议的其他技术要素。关于隐身伪装机制的详细分析，请参阅 [隐身伪装技术](/k2/stealth)。

### k2v5 URL 格式

k2v5 将所有连接参数编码到单个 URL 中：

```
k2v5://USERNAME:PASSWORD@HOST:PORT?ech=ECH_CONFIG&pin=sha256:CERT_HASH&fp=FINGERPRINT&hop=PORT_RANGE
```

| 参数 | 说明 | 示例 |
|------|------|------|
| `USERNAME` | 用户名 | `abc123` |
| `PASSWORD` | 认证密码 | `tok456` |
| `HOST` | 服务端 IP 或域名 | `203.0.113.5` |
| `PORT` | 服务端端口（通常 443） | `443` |
| `ech` | Base64 编码的 ECH 配置 | `AEX0...` |
| `pin` | 服务端证书的 SHA-256 哈希 | `sha256:abc...` |
| `fp` | TLS 指纹类型（chrome/firefox/safari/random） | `chrome` |
| `hop` | UDP 端口跳跃范围（可选） | `10000-20000` |

### 三层身份体系

k2v5 连接过程中存在三层可观测的身份信息：

```
层级         明文可见  内容
─────────────────────────────────────────────────────────
1. TCP 目标  是        服务端真实 IP 地址
2. 外层 SNI  是        某主流 CDN 公共域名（ECH public_name）
3. 内层 SNI  否        k2 服务端域名（被 ECH 加密）
```

网络旁观者（ISP、GFW）只能看到第 1 层和第 2 层。第 3 层被 ECH 完整加密，无法在不持有 ECH 私钥的情况下解密。

### ECH 配置派生

k2s 生成的 ECH 配置从某主流 CDN 的真实 ECH 配置派生：

1. 查询该 CDN 公共域名的 DNS HTTPS 记录，获取 ECH 配置模板
2. 复制 `cipher_suites`、`kem_id`、`public_name` 等字段
3. 递增 `config_id`（避免与真实配置冲突）
4. 替换 HPKE 公钥为 k2s 自己的公钥

结果：k2 流量的 ECH 配置与该 CDN 的真实流量在结构上无法区分。

### 证书与固定

k2s 使用**自签名证书**，不依赖任何 CA。

- **双证书设计**：EC 证书 + RSA 证书，与真实 CDN 的证书多样性匹配
- **证书固定**：URL 中的 `pin=sha256:HASH` 是证书公钥的 SHA-256 哈希，客户端直接比对
- 自签名证书不出现在 Certificate Transparency（CT）日志中，避免被 CT 扫描检测

### TLS 记录填充

k2s 定期（每 24 小时）从 ECH 伪装目标域名下载真实证书链，测量其 TLS Record 大小分布，并用相同的填充长度发送 TLS 握手记录。k2 握手的流量特征（数据包大小分布）与真实 CDN 的 HTTPS 流量匹配。

### 传输层

**QUIC/H3（主传输）**：基于 QUIC 的 HTTP/3 传输，原生多路复用、无队头阻塞。k2arc 算法直接控制 QUIC 的发送速率。

**TCP-WebSocket（回退传输）**：当 QUIC 被 UDP 封锁时自动切换。使用 smux 在单个 WebSocket 连接上实现多路复用。切换过程对应用层透明。

**TransportManager** 封装统一的 `Dialer` 接口：优先 QUIC → QUIC 失败回退 TCP-WS → 连接状态监控与自动重连。

### UDP 端口跳跃

当 URL 包含 `hop=START-END` 参数时，k2 客户端在 QUIC 传输中随机选择端口范围内的 UDP 端口，定期更换，对抗基于固定端口的 UDP QoS 限速。

### 服务端 ECH 路由

k2s 在接收 TLS 连接时检查 ClientHello：

- **有 ECH 扩展**：解密 ECH，验证身份，进入 k2v5 隧道处理
- **无 ECH 扩展**：将原始 TCP 连接透明转发到 `public_name` 对应的真实 CDN 服务器

非 ECH 连接收到的是真实 CDN 响应，探测脚本无法区分 k2s 与真实 CDN 服务器。

---

## 常见问题

**k2arc 和标准 PCC Vivace 是什么关系？**

k2arc 基于 PCC Vivace 的效用函数框架和梯度上升策略，但在几乎所有参数上都做了针对审查网络的调优——慢启动增长 +25%、探测步长 3×、EWMA 响应 +20%、恢复探测频率 2×。最关键的创新是自适应丢包惩罚系数 α，这是标准 PCC 中没有的机制。

**α = 0.5 不会在真正拥塞时造成问题吗？**

GFW 模式（α = 0.5）专为审查网络设计，在这类网络中丢包主要来自防火墙主动丢弃而非拥塞。如果网络环境混合存在审查丢包和拥塞丢包，自适应模式（α 自动调节）是更好的选择——它能根据实时丢包率自动调整惩罚力度。效用函数中的 β×ΔRtt 延迟惩罚项也提供了额外的拥塞检测信号。

**为什么 β 只有 0.1，不会导致 bufferbloat 吗？**

β = 0.1 是隧道场景的有意选择。隧道用户的首要需求是吞吐量而非延迟。同时，β×ΔRtt 项仍然有效——当路由器缓冲区堆积导致 RTT 上升 100ms 时，延迟惩罚为 10（相当于 10 Mbps 的吞吐量对冲），足以触发速率下调。k2arc 的 pacing 机制也通过均匀分布数据包发送时间来主动抑制队列堆积。

**k2arc 如何与 QUIC 的拥塞控制配合？**

k2arc 完全替代了 QUIC 默认的拥塞控制（通常为 NewReno 或 Cubic）。它通过实现 `CongestionControl` 接口直接控制 QUIC 的拥塞窗口和发送速率，QUIC 层不再运行自己的拥塞算法。

**k2arc 的技术细节如何验证？**

k2 项目内置了 14 种网络场景的基准测试套件，基于 RFC 8867、QUICbench (IMC 2022)、USENIX Security 2023/2025 的学术研究设计。详细的测评方法和场景说明见 [k2 vs Hysteria2 拥塞控制对比](/k2/vs-hysteria2)。

---

接下来阅读：[隐身伪装技术](/k2/stealth) 从威胁模型角度分析 k2 的对抗能力，[k2 vs Hysteria2](/k2/vs-hysteria2) 查看 k2arc 与 Brutal/BBR 的性能对比，或 [k2 vs VLESS+Reality](/k2/vs-reality) 了解 k2 与 Reality 的隐身路线对比。
