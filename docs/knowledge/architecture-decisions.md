# Architecture Decisions

Knowledge distilled from executed features. Links to validating tests.

---

## VpnClient Abstraction Pattern (2026-02-14, k2app-rewrite)

**Decision**: Webapp communicates with VPN backends through a unified `VpnClient` interface, never making direct HTTP calls to the daemon outside the `vpn-client/` module.

**Implementations**:
- `HttpVpnClient` (desktop): HTTP to `http://127.0.0.1:1777` + internal 2s polling converted to events
- `MockVpnClient` (testing): Controllable test double with setter methods and call tracking
- `NativeVpnClient` (mobile): Capacitor Plugin bridge via constructor-injected K2Plugin

**Key patterns**:
- Factory function `createVpnClient(override?)` for dependency injection
- All commands (`connect`, `disconnect`) resolve when accepted, NOT when operation completes
- Event subscription with automatic poll management (start on first subscriber, stop on zero)
- State deduplication in polling loop prevents redundant event emissions

**Why it works**:
- Single abstraction supports desktop HTTP, mobile native bridge, and test mocks
- Webapp code is platform-agnostic (same code on desktop/mobile/web)
- Polling-to-event transformation hides desktop's lack of native push events

**Validating tests**: `webapp/src/vpn-client/__tests__/` — http-client, index, mock-client, native-client

---

## Service Version Matching with Build Metadata (2026-02-14, k2app-rewrite)

**Decision**: Compare service and app versions by stripping build metadata after `+` character. See `desktop/src-tauri/src/service.rs:88` — `versions_match()`.

**Why**: k2 binary version includes commit hash (e.g., `0.4.0+abc123`) while Tauri config has clean `0.4.0`. Per semver spec, build metadata after `+` is ignored for precedence.

**Validating tests**: `desktop/src-tauri/src/service.rs` — `test_versions_match_with_build_metadata`

---

## Antiblock Entry URL Resolution (2026-02-14, k2app-rewrite)

**Decision**: Webapp resolves Cloud API entry URL through multi-source fallback chain with localStorage cache.

**Flow**: localStorage cache → JSONP fetch from npm CDN mirrors (jsDelivr, unpkg) → base64 decode → hardcoded default fallback.

**Why this approach**:
- Standard HTTPS (no custom CA), fast rotation via npm package publish
- Multi-CDN prevents single point of failure
- Base64 obfuscation prevents automated text scanning (not security, just evasion)
- No frontend encryption — any JS key is extractable anyway

**Validating tests**: `webapp/src/api/__tests__/antiblock.test.ts` — cache, CDN fallback, decoding

---

## Old Service Cleanup on Upgrade (2026-02-14, k2app-rewrite)

**Decision**: Detect and remove old kaitu-service 0.3.x on first launch of k2app 0.4.0.

**Detection**: macOS checks LaunchDaemons plists; Windows checks `sc query kaitu-service`.
**Cleanup**: macOS `launchctl unload` + delete; Windows `sc stop && sc delete`.
**Why**: Old and new service both listen on :1777 — automatic cleanup prevents conflict.

**Validating tests**: `desktop/src-tauri/src/service.rs` — `test_detect_old_kaitu_service_no_crash`

---

## tauri-plugin-localhost for Mixed Content (2026-02-14, k2app-rewrite)

**Decision**: Serve webapp from `http://localhost:14580` instead of `https://tauri.localhost` to avoid WebKit mixed content blocking when calling HTTP daemon.

**Why**: WebKit (macOS, Linux) strictly blocks `https://` → `http://` requests even for loopback. Serving the webapp over HTTP eliminates mixed content. Security model unchanged — localhost already exposed via daemon :1777.

**Cross-reference**: See Framework Gotchas → "WebKit Mixed Content Blocking on macOS" for full details.

**Validating tests**: Integration test — fetch `/ping` from webview succeeds on macOS.

---

## Single Source of Truth for Versioning (2026-02-14, k2app-rewrite)

**Decision**: Root `package.json` version is the single source. All derivations:
- `tauri.conf.json` → `"version": "../../package.json"` (Tauri native reference)
- k2 binary → Makefile ldflags `-X main.version=$(VERSION)`
- webapp → `public/version.json` (generated by `make pre-build`)
- Release → git tags `v$(VERSION)`

**Why**: Prevents version drift. Single update point for releases.

**Validating tests**: `scripts/test_version_propagation.sh`

---

## NativeVpnClient Mobile Bridge (2026-02-14, mobile-rewrite)

**Decision**: NativeVpnClient wraps Capacitor K2Plugin behind VpnClient interface. Plugin is constructor-injected and loaded via dynamic import to avoid bundling mobile-only deps in desktop builds.

**Factory chain**: `initVpnClient()` (async, detects native platform) → `NativeVpnClient(plugin)` or `HttpVpnClient()`.

**Three-layer state mapping** (defense in depth): Go Engine `"disconnected"` → K2Plugin native `remapStatusKeys` → NativeVpnClient TS `mapState()`. All map `"disconnected"` → `"stopped"`.

**Why constructor injection**: Enables testing with mock plugin — K2Plugin is Capacitor-specific, cannot be imported outside native runtime.

**Validating tests**: `webapp/src/vpn-client/__tests__/native-client.test.ts` — 18 tests

---

## iOS Two-Process vs Android Single-Process VPN (2026-02-14, mobile-rewrite)

**Decision**: iOS uses NEPacketTunnelProvider (separate NE process). Android runs everything in one process.

**iOS** (two processes): Main App → NETunnelProviderManager; NE Process → PacketTunnelProvider → gomobile Engine. Communication via `sendProviderMessage()` for status, `NEVPNStatusDidChange` for events, App Group UserDefaults for shared state.

**Android** (single process): K2Plugin → K2VpnService → gomobile Engine. Direct method calls (same process). K2Plugin binds via `bindService()`.

**Why different**: Apple requires VPN tunnels in NE extension (sandboxed process). Android VpnService runs in app process. This fundamentally changes status query pattern: iOS needs IPC, Android calls Engine directly.

**Validating tests**: Manual device testing on both platforms.

---

## iOS NE→App Error Propagation via App Group + cancelTunnelWithError (2026-02-16, ios-vpn-fixes)

**Decision**: NE process writes error text to App Group UserDefaults (`vpnError` key), then calls `cancelTunnelWithError(error)` to trigger system disconnect. Main app reads error from App Group in `NEVPNStatusDidChange` handler when status is `.disconnected`, pushes `vpnError` event to JS, then clears the key.

**Why this pattern**: iOS NE and main app are separate processes — no direct method calls or callbacks. The system provides exactly one real-time push channel from NE→App: `NEVPNStatusDidChange`. App Group provides the data channel. Together: NE writes error → triggers system notification → App reads error on notification.

**State source of truth**: `NEVPNStatusDidChange` is the ONLY VPN state source in the main app. All previous `UserDefaults("vpnState")` writes from NE were removed as orphaned (written but never read by main app). K2Plugin maps `NEVPNStatus` enum to `"connected"/"connecting"/"stopped"` strings.

**Error flow**: Go Engine error → `EventBridge.onError()` → App Group write + `cancelTunnelWithError(error)` → system sends `.disconnected` → K2Plugin reads App Group `vpnError` → JS `vpnError` event → clears key.

**State flow**: Go Engine disconnect → `EventBridge.onStateChange("disconnected")` → `cancelTunnelWithError(nil)` → system sends `.disconnected` → K2Plugin maps to `"stopped"` → JS `vpnStateChange` event.

**Files**: `PacketTunnelProvider.swift` (NE side), `K2Plugin.swift` (App side)

**Validating tests**: Manual device testing — no test yet.

---

## Go→JS JSON Key Remapping at Native Bridge (2026-02-14, mobile-rewrite)

**Decision**: Go `json.Marshal` outputs snake_case; native bridge layers (K2Plugin.swift/kt) remap to camelCase before passing to webapp.

**Key map**: `connected_at→connectedAt`, `uptime_seconds→uptimeSeconds`, `wire_url→wireUrl`. Also `"disconnected"→"stopped"` for state field.

**Why remap at bridge, not Go**: Go convention is snake_case (changing requires struct tags across all code). Native bridge is the natural boundary. TypeScript expects camelCase.

**Cross-reference**: See Framework Gotchas → "Go json.Marshal snake_case vs JavaScript camelCase" for the discovery story. See Bugfix Patterns → "Go→JS JSON Key Mismatch" for the original bug.

**Validating tests**: `webapp/src/vpn-client/__tests__/native-client.test.ts` — `getStatus()` verifies camelCase keys

---

## Android AAR: Direct flatDir, No Wrapper Module (2026-02-16, android-aar-fix)

**Decision**: Remove `k2-mobile` wrapper module. App module references `k2mobile.aar` directly via Gradle `flatDir` + `implementation(name: 'k2mobile', ext: 'aar')`.

**Context**: gomobile bind produces `k2mobile.aar`. Originally a `k2-mobile` wrapper module used `api files('libs/k2mobile.aar')` — but `files()` treats AARs as JARs, losing Android resource/manifest handling.

**Why only app needs AAR**: k2-plugin module uses `VpnServiceBridge` interface (decoupled from AAR). Only `app` module's `K2VpnService` directly instantiates gomobile `Engine`. So only one consumer needs the AAR.

**Build pipeline**: `gomobile bind` → `k2/build/k2mobile.aar` → copy to `mobile/android/app/libs/` → Gradle resolves via flatDir.

**Alternatives rejected**:
- **Plan A** (keep wrapper): `api files()` doesn't work for AAR, `api` dependency exposed AAR transitively but incorrectly.
- **Plan B** (flatDir in all modules): Unnecessary — only app needs it.

**Validating tests**: `./gradlew assembleRelease` succeeds; APK contains `libgojni.so` for all 4 ABIs.

---

## Build System: Makefile Orchestration + Script Composition (2026-02-14)

**Decision**: Makefile handles version extraction and target orchestration. Platform-specific build logic lives in `scripts/build-*.sh`.

**Pattern**: `make pre-build` (version.json) → `make build-webapp` → platform-specific target (`build-macos`, `build-windows`, `build-mobile-ios`, `build-mobile-android`).

**Why Makefile + scripts**:
- Makefile provides declarative dependency graph and variable extraction
- Scripts handle platform conditionals (codesign, xcodebuild, gradlew) that are awkward in Make
- CI workflows call `make` targets — same commands locally and in CI

**Key gotcha**: `k2/build/` directory must exist before `gomobile bind` — Makefile creates it.

**Validating tests**: `scripts/test_build.sh` — 14 build verification checks

---

## Decoupled Code Signing for Windows Releases (2026-02-14)

**Decision**: Windows code signing happens outside GitHub Actions via an external `kaitu-signer` service orchestrated through S3 + SQS.

**Flow**: CI uploads unsigned .exe to S3 (scoped by run ID) → SQS message triggers external signer → signer signs with SimpliSign + TOTP → uploads signed artifact to S3 → CI polls with `scripts/ci/wait-for-signing.sh` (10s intervals, 600s timeout).

**Why decoupled**: Windows code signing requires hardware token access or cloud HSM. Neither is available inside GitHub Actions runners. S3-based artifact exchange is simple, auditable, and supports concurrent releases via run ID scoping.

**Validating tests**: Release workflow dry-run; `wait-for-signing.sh` timeout handling

---

## Vite Multi-Page Entry for Debug/Diagnostic Pages (2026-02-16, mobile-debug)

**Decision**: Use Vite `rollupOptions.input` to add standalone HTML pages alongside the main React app. `debug.html` is a second entry point — pure HTML+JS, no React/Store/Auth, shares the same `dist/` output.

**Why multi-page, not separate project**: Same build pipeline, zero Capacitor config changes. `cap sync` copies entire `dist/` including `debug.html`. Dev server serves both entries automatically.

**Key insight**: Capacitor bridge is **WebView-level**, not page-level. Any HTML loaded within the same Capacitor WebView has access to `window.Capacitor.Plugins.K2Plugin`. This means standalone debug pages can call native plugins directly without going through the React app's bootstrap chain.

**Navigation**: `window.location.href = '/debug.html'` causes full page navigation — React unmounts, debug page loads fresh. Return via back navigation re-initializes React (acceptable for debug tool).

**Pattern applicability**: Any Capacitor/Tauri app needing isolated diagnostic pages without framework dependencies. Useful for:
- Native bridge debugging (this use case)
- Network diagnostics
- Performance profiling pages

**Validating tests**: `yarn build` produces both `dist/index.html` and `dist/debug.html`; `webapp/src/pages/__tests__/Settings.test.tsx` validates hidden entry point.

---

## App.tsx Route Wiring + Global Component Integration (2026-02-16, kaitu-feature-migration)

**Decision**: App.tsx is the single entry point for all routing, guards, and global overlays. No AuthGuard redirect — use LoginRequiredGuard (opens LoginDialog) and MembershipGuard (redirects to /purchase).

**Route structure (20 routes)**:
- 4 tab routes (keep-alive via Layout): `/`, `/purchase`, `/invite` (LoginRequired), `/account`
- 6 login-required sub-pages: `/devices`, `/member-management`, `/pro-histories`, `/invite-codes`, `/issues`, `/issues/:number`
- 2 membership-required sub-pages: `/update-email`, `/submit-ticket`
- 4 open sub-pages: `/device-install`, `/faq`, `/changelog`, `/discover`

**Global component stack** (rendered outside Routes, inside BrowserRouter):
```
ErrorBoundary > BrowserRouter > ServiceReadiness > [
  ForceUpgradeDialog, AnnouncementBanner, ServiceAlert,
  UpdatePrompt, AlertContainer, LoginDialog, Routes
]
```

**App init**: `useEffect` calls `restoreSession()` + `loadAppConfig()` on mount. App config needed for ForceUpgradeDialog and feature flags.

**Version injection**: Vite `define: { __APP_VERSION__: pkg.version }` — no PlatformApi version needed.

**Validating tests**: All 279 tests pass; `npx tsc --noEmit` clean.

---

## PlatformApi Abstraction for Cross-Platform Capabilities (2026-02-16, kaitu-feature-migration)

**Decision**: Create `PlatformApi` interface to abstract platform-specific capabilities (clipboard, external browser, locale sync, log upload). Three implementations: `TauriPlatform`, `CapacitorPlatform`, `WebPlatform` (fallback).

**Factory pattern**: `createPlatform()` auto-detects environment via `window.__TAURI__` / `window.Capacitor`. Singleton via `getPlatform()` caches instance.

**Why this approach**:
- Same VpnClient pattern (DI-friendly abstraction)
- Webapp code stays platform-agnostic — no conditional imports
- Test injection via factory override parameter
- Capacitor and Tauri both expose platform APIs via window globals (perfect for detection)

**Key interfaces**:
```typescript
interface PlatformApi {
  openExternal(url: string): Promise<void>;
  writeClipboard(text: string): Promise<void>;
  syncLocale?(lang: string): Promise<void>;
  uploadLogs?(feedbackId: string): Promise<void>;
  isMobile: boolean;
  version: string;
}
```

**Validating tests**: `webapp/src/platform/__tests__/platform.test.ts` — 8 tests covering all implementations

---

## Dark-Only Theme via CSS Variables (2026-02-16, kaitu-feature-migration)

**Decision**: Ship exclusively dark mode. No light theme. No theme switcher. All design tokens defined as CSS custom properties in `app.css` under `@theme`.

**Why dark-only**:
- Reduces code complexity — no `dark:` Tailwind prefix, no theme toggle state
- No ThemeContext or theme store needed
- Faster development — design once, no light mode variants
- Product decision — kaitu brand is dark aesthetic

**Token architecture**:
- Base colors: `--color-bg-default`, `--color-bg-paper`, `--color-text-primary`
- Semantic status: `--color-success`, `--color-warning`, `--color-error`, `--color-info` (each with `-light`, `-dark`, `-bg`, `-border`, `-glow` variants)
- Component tokens: `--color-card-bg`, `--color-selected-border`, `--color-divider`
- All components use tokens via `bg-[--color-*]` pattern — zero hardcoded hex values in component files

**Migration note**: Replicated kaitu webapp's dark palette exactly (`theme.ts` dark object + `theme/colors.ts`). MUI `sx` props → Tailwind classes with CSS variables.

**Validating tests**: `webapp/src/components/__tests__/dark-theme.test.ts` — verifies CSS variables applied on body

---

## Unified Engine Package for Desktop + Mobile (2026-02-16, unified-engine)

**Decision**: Extract shared tunnel lifecycle logic from desktop `daemon/tunnel.go` and mobile `mobile/mobile.go` into a single `k2/engine/` package. Desktop daemon becomes a thin HTTP shell over `engine.Engine`. Mobile wrapper becomes a gomobile type adapter.

**Engine package structure**:
- `engine/engine.go` — Engine struct, Start(), Stop(), StatusJSON(), Status()
- `engine/config.go` — Config struct with platform-specific optional fields
- `engine/event.go` — EventHandler interface + state constants
- `engine/dns_handler.go` — DNS middleware for mobile TUN (moved from mobile/)
- `engine/engine_test.go` — 14 unit tests covering all config combinations

**Key design: Config.FileDescriptor discriminates platform behavior**:
- `fd >= 0` → Mobile (platform provides TUN fd, use DNS middleware)
- `fd == -1` → Desktop (self-create TUN with route exclusion)

**Optional Config fields for desktop-only features**:
- `DirectDialer` — Custom outbound interface binding
- `PreferIPv6` — Wire server IPv6 preference
- `Mode == "proxy"` → SOCKS5 proxy instead of TUN
- `DNSExclude` — Route exclusion for DNS servers
- `RuleConfig` — Complete k2rule config (overrides RuleMode)

**Mobile simplification**: `mobile/mobile.go` reduced from 251 lines to 57 lines by delegating everything to `engine.Engine`.

**Desktop simplification**: `daemon/tunnel.go` deleted — its `BuildTunnel()` logic is now `engine.Start()`.

**Why unified**: 80% code duplication eliminated. Single tunnel assembly implementation ensures consistent behavior across platforms. Desktop-specific features isolated to optional Config fields.

**Validating tests**: `k2/engine/engine_test.go` — TestEngineStart_MobileConfig, TestEngineStart_DesktopConfig, TestEngineStart_ProxyMode

---

## Mobile Rule Mode Storage + URL Parameter Flow (2026-02-16, unified-engine)

**Decision**: Mobile rule mode (global vs smart routing) stored in platform-native persistent storage. Native plugins append `&rule=xxx` to wireUrl before starting VPN. Engine parses rule mode from URL query parameter.

**Storage locations**:
- **iOS**: `UserDefaults(suiteName: "group.io.kaitu")` key `"ruleMode"` (App Group shared between main app and NE)
- **Android**: `SharedPreferences("k2vpn")` key `"ruleMode"`
- **Desktop**: Not applicable — uses `config.yaml` `rule.global` field

**Data directory for k2rule cache**:
- **iOS**: App Group container path + `/k2` (e.g., `/private/var/mobile/Containers/Shared/AppGroup/.../group.io.kaitu/k2`)
- **Android**: `context.filesDir.absolutePath` (e.g., `/data/user/0/io.kaitu/files`)
- **Desktop**: `~/.cache/k2rule/` (set via RuleConfig, not via DataDir field)

**Flow**:
1. Webapp calls `setRuleMode("smart")` → K2Plugin saves to native storage
2. User clicks connect → K2Plugin reads ruleMode, appends `&rule=smart` to wireUrl
3. Native VPN service passes modified wireUrl to gomobile `engine.start(wireUrl, fd, dataDir)`
4. Engine parses URL query `rule=smart`, initializes k2rule with `IsGlobal: false` + `CacheDir: dataDir`

**iOS NE cold start**: ruleMode is embedded in `providerConfiguration.wireUrl` when VPN starts. NE reads directly from URL, no need to re-read UserDefaults.

**Why URL parameter**: Decouples rule mode from VPN connection state. Disconnect+reconnect is the only way to change modes. No hot-switching complexity.

**Files**: `K2Plugin.swift`, `K2Plugin.kt`, `engine/engine.go` parseRuleFromURL helper

**Validating tests**: Manual device testing — no automated test yet.

---

## Global LoginDialog Modal Replaces Login Route (2026-02-16, kaitu-feature-migration)

**Decision**: Remove dedicated `/login` route. All authentication flows use a global `LoginDialog` modal component triggered on demand.

**Trigger sources**:
- App startup (AuthGuard): if no valid session, open dialog automatically
- Protected routes (LoginRequiredGuard): redirect → open dialog with context
- Feature pages (Purchase, Invite): click "login to continue" → open dialog with custom message

**State management**: `login-dialog.store.ts` Zustand store with `{ isOpen, trigger, message, open(), close() }`. On success, dialog closes and triggering page refreshes.

**Why modal over route**:
- No route navigation disruption — user stays on intended page
- Context-aware messaging ("Login to purchase" vs "Login to manage invites")
- Purchase page can show inline login form for unauthenticated users (same EmailLoginForm component)
- Mobile UX: modal feels more native than full-page route change

**Validating tests**: `webapp/src/components/__tests__/LoginDialog.test.tsx`, `webapp/src/components/__tests__/guards.test.tsx`

---

## Keep-Alive Tab Pattern for Tab Pages (2026-02-16, kaitu-feature-migration)

**Decision**: Tab pages (Dashboard, Purchase, Invite, Account) are mounted on first visit, then hidden (not unmounted) when switching tabs.

**Implementation**: `Layout.tsx` tracks mounted tabs in `useState`. Active tab rendered normally; inactive tabs use `visibility: hidden` + `position: absolute` CSS.

**Why keep-alive**:
- Preserves scroll position when switching tabs
- Maintains component state (form inputs, expanded sections)
- Reduces re-fetch on tab return (data stays loaded)
- Better perceived performance (instant tab switch, no loading spinner)

**Trade-off**: More memory usage (4 tab DOMs in memory). Acceptable for 4-tab app.

**Non-tab pages**: Sub-pages (`/devices`, `/issues`, etc.) use normal React Router `<Outlet />` — mount/unmount on navigate.

**Validating tests**: `webapp/src/components/__tests__/Layout.keepalive.test.ts`

---
