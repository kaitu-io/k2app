# Architecture Decisions

Knowledge distilled from executed features. Links to validating tests.

---

## VpnClient Abstraction Pattern (2026-02-14, k2app-rewrite)

**Decision**: Webapp communicates with VPN backends through a unified `VpnClient` interface, never making direct HTTP calls to the daemon outside the `vpn-client/` module.

**Implementations**:
- `HttpVpnClient` (desktop): HTTP to `http://127.0.0.1:1777` + internal 2s polling converted to events
- `MockVpnClient` (testing): Controllable test double with setter methods and call tracking
- `NativeVpnClient` (mobile): Capacitor Plugin bridge via constructor-injected K2Plugin

**Key patterns**:
- Factory function `createVpnClient(override?)` for dependency injection
- All commands (`connect`, `disconnect`) resolve when accepted, NOT when operation completes
- Event subscription with automatic poll management (start on first subscriber, stop on zero)
- State deduplication in polling loop prevents redundant event emissions

**Why it works**:
- Single abstraction supports desktop HTTP, mobile native bridge, and test mocks
- Webapp code is platform-agnostic (same code on desktop/mobile/web)
- Polling-to-event transformation hides desktop's lack of native push events

**Validating tests**: `webapp/src/vpn-client/__tests__/` — http-client, index, mock-client, native-client

---

## Service Version Matching with Build Metadata (2026-02-14, k2app-rewrite)

**Decision**: Compare service and app versions by stripping build metadata after `+` character. See `desktop/src-tauri/src/service.rs:88` — `versions_match()`.

**Why**: k2 binary version includes commit hash (e.g., `0.4.0+abc123`) while Tauri config has clean `0.4.0`. Per semver spec, build metadata after `+` is ignored for precedence.

**Validating tests**: `desktop/src-tauri/src/service.rs` — `test_versions_match_with_build_metadata`

---

## Antiblock Entry URL Resolution (2026-02-14, k2app-rewrite)

**Decision**: Webapp resolves Cloud API entry URL through multi-source fallback chain with localStorage cache.

**Flow**: localStorage cache → JSONP fetch from npm CDN mirrors (jsDelivr, unpkg) → base64 decode → hardcoded default fallback.

**Why this approach**:
- Standard HTTPS (no custom CA), fast rotation via npm package publish
- Multi-CDN prevents single point of failure
- Base64 obfuscation prevents automated text scanning (not security, just evasion)
- No frontend encryption — any JS key is extractable anyway

**Validating tests**: `webapp/src/api/__tests__/antiblock.test.ts` — cache, CDN fallback, decoding

---

## Old Service Cleanup on Upgrade (2026-02-14, k2app-rewrite)

**Decision**: Detect and remove old kaitu-service 0.3.x on first launch of k2app 0.4.0.

**Detection**: macOS checks LaunchDaemons plists; Windows checks `sc query kaitu-service`.
**Cleanup**: macOS `launchctl unload` + delete; Windows `sc stop && sc delete`.
**Why**: Old and new service both listen on :1777 — automatic cleanup prevents conflict.

**Validating tests**: `desktop/src-tauri/src/service.rs` — `test_detect_old_kaitu_service_no_crash`

---

## tauri-plugin-localhost for Mixed Content (2026-02-14, k2app-rewrite)

**Decision**: Serve webapp from `http://localhost:14580` instead of `https://tauri.localhost` to avoid WebKit mixed content blocking when calling HTTP daemon.

**Why**: WebKit (macOS, Linux) strictly blocks `https://` → `http://` requests even for loopback. Serving the webapp over HTTP eliminates mixed content. Security model unchanged — localhost already exposed via daemon :1777.

**Cross-reference**: See Framework Gotchas → "WebKit Mixed Content Blocking on macOS" for full details.

**Validating tests**: Integration test — fetch `/ping` from webview succeeds on macOS.

---

## Single Source of Truth for Versioning (2026-02-14, k2app-rewrite)

**Decision**: Root `package.json` version is the single source. All derivations:
- `tauri.conf.json` → `"version": "../../package.json"` (Tauri native reference)
- k2 binary → Makefile ldflags `-X main.version=$(VERSION)`
- webapp → `public/version.json` (generated by `make pre-build`)
- Release → git tags `v$(VERSION)`

**Why**: Prevents version drift. Single update point for releases.

**Validating tests**: `scripts/test_version_propagation.sh`

---

## NativeVpnClient Mobile Bridge (2026-02-14, mobile-rewrite)

**Decision**: NativeVpnClient wraps Capacitor K2Plugin behind VpnClient interface. Plugin is constructor-injected and loaded via dynamic import to avoid bundling mobile-only deps in desktop builds.

**Factory chain**: `initVpnClient()` (async, detects native platform) → `NativeVpnClient(plugin)` or `HttpVpnClient()`.

**Three-layer state mapping** (defense in depth): Go Engine `"disconnected"` → K2Plugin native `remapStatusKeys` → NativeVpnClient TS `mapState()`. All map `"disconnected"` → `"stopped"`.

**Why constructor injection**: Enables testing with mock plugin — K2Plugin is Capacitor-specific, cannot be imported outside native runtime.

**Validating tests**: `webapp/src/vpn-client/__tests__/native-client.test.ts` — 18 tests

---

## iOS Two-Process vs Android Single-Process VPN (2026-02-14, mobile-rewrite)

**Decision**: iOS uses NEPacketTunnelProvider (separate NE process). Android runs everything in one process.

**iOS** (two processes): Main App → NETunnelProviderManager; NE Process → PacketTunnelProvider → gomobile Engine. Communication via `sendProviderMessage()` for status, `NEVPNStatusDidChange` for events, App Group UserDefaults for shared state.

**Android** (single process): K2Plugin → K2VpnService → gomobile Engine. Direct method calls (same process). K2Plugin binds via `bindService()`.

**Why different**: Apple requires VPN tunnels in NE extension (sandboxed process). Android VpnService runs in app process. This fundamentally changes status query pattern: iOS needs IPC, Android calls Engine directly.

**Validating tests**: Manual device testing on both platforms.

---

## Go→JS JSON Key Remapping at Native Bridge (2026-02-14, mobile-rewrite)

**Decision**: Go `json.Marshal` outputs snake_case; native bridge layers (K2Plugin.swift/kt) remap to camelCase before passing to webapp.

**Key map**: `connected_at→connectedAt`, `uptime_seconds→uptimeSeconds`, `wire_url→wireUrl`. Also `"disconnected"→"stopped"` for state field.

**Why remap at bridge, not Go**: Go convention is snake_case (changing requires struct tags across all code). Native bridge is the natural boundary. TypeScript expects camelCase.

**Cross-reference**: See Framework Gotchas → "Go json.Marshal snake_case vs JavaScript camelCase" for the discovery story. See Bugfix Patterns → "Go→JS JSON Key Mismatch" for the original bug.

**Validating tests**: `webapp/src/vpn-client/__tests__/native-client.test.ts` — `getStatus()` verifies camelCase keys

---

## Android AAR: Direct flatDir, No Wrapper Module (2026-02-16, android-aar-fix)

**Decision**: Remove `k2-mobile` wrapper module. App module references `k2mobile.aar` directly via Gradle `flatDir` + `implementation(name: 'k2mobile', ext: 'aar')`.

**Context**: gomobile bind produces `k2mobile.aar`. Originally a `k2-mobile` wrapper module used `api files('libs/k2mobile.aar')` — but `files()` treats AARs as JARs, losing Android resource/manifest handling.

**Why only app needs AAR**: k2-plugin module uses `VpnServiceBridge` interface (decoupled from AAR). Only `app` module's `K2VpnService` directly instantiates gomobile `Engine`. So only one consumer needs the AAR.

**Build pipeline**: `gomobile bind` → `k2/build/k2mobile.aar` → copy to `mobile/android/app/libs/` → Gradle resolves via flatDir.

**Alternatives rejected**:
- **Plan A** (keep wrapper): `api files()` doesn't work for AAR, `api` dependency exposed AAR transitively but incorrectly.
- **Plan B** (flatDir in all modules): Unnecessary — only app needs it.

**Validating tests**: `./gradlew assembleRelease` succeeds; APK contains `libgojni.so` for all 4 ABIs.

---

## Build System: Makefile Orchestration + Script Composition (2026-02-14)

**Decision**: Makefile handles version extraction and target orchestration. Platform-specific build logic lives in `scripts/build-*.sh`.

**Pattern**: `make pre-build` (version.json) → `make build-webapp` → platform-specific target (`build-macos`, `build-windows`, `build-mobile-ios`, `build-mobile-android`).

**Why Makefile + scripts**:
- Makefile provides declarative dependency graph and variable extraction
- Scripts handle platform conditionals (codesign, xcodebuild, gradlew) that are awkward in Make
- CI workflows call `make` targets — same commands locally and in CI

**Key gotcha**: `k2/build/` directory must exist before `gomobile bind` — Makefile creates it.

**Validating tests**: `scripts/test_build.sh` — 14 build verification checks

---

## Decoupled Code Signing for Windows Releases (2026-02-14)

**Decision**: Windows code signing happens outside GitHub Actions via an external `kaitu-signer` service orchestrated through S3 + SQS.

**Flow**: CI uploads unsigned .exe to S3 (scoped by run ID) → SQS message triggers external signer → signer signs with SimpliSign + TOTP → uploads signed artifact to S3 → CI polls with `scripts/ci/wait-for-signing.sh` (10s intervals, 600s timeout).

**Why decoupled**: Windows code signing requires hardware token access or cloud HSM. Neither is available inside GitHub Actions runners. S3-based artifact exchange is simple, auditable, and supports concurrent releases via run ID scoping.

**Validating tests**: Release workflow dry-run; `wait-for-signing.sh` timeout handling

---

## Vite Multi-Page Entry for Debug/Diagnostic Pages (2026-02-16, mobile-debug)

**Decision**: Use Vite `rollupOptions.input` to add standalone HTML pages alongside the main React app. `debug.html` is a second entry point — pure HTML+JS, no React/Store/Auth, shares the same `dist/` output.

**Why multi-page, not separate project**: Same build pipeline, zero Capacitor config changes. `cap sync` copies entire `dist/` including `debug.html`. Dev server serves both entries automatically.

**Key insight**: Capacitor bridge is **WebView-level**, not page-level. Any HTML loaded within the same Capacitor WebView has access to `window.Capacitor.Plugins.K2Plugin`. This means standalone debug pages can call native plugins directly without going through the React app's bootstrap chain.

**Navigation**: `window.location.href = '/debug.html'` causes full page navigation — React unmounts, debug page loads fresh. Return via back navigation re-initializes React (acceptable for debug tool).

**Pattern applicability**: Any Capacitor/Tauri app needing isolated diagnostic pages without framework dependencies. Useful for:
- Native bridge debugging (this use case)
- Network diagnostics
- Performance profiling pages

**Validating tests**: `yarn build` produces both `dist/index.html` and `dist/debug.html`; `webapp/src/pages/__tests__/Settings.test.tsx` validates hidden entry point.

---

## PlatformApi Abstraction for Cross-Platform Capabilities (2026-02-16, kaitu-feature-migration)

**Decision**: Create `PlatformApi` interface to abstract platform-specific capabilities (clipboard, external browser, locale sync, log upload). Three implementations: `TauriPlatform`, `CapacitorPlatform`, `WebPlatform` (fallback).

**Factory pattern**: `createPlatform()` auto-detects environment via `window.__TAURI__` / `window.Capacitor`. Singleton via `getPlatform()` caches instance.

**Why this approach**:
- Same VpnClient pattern (DI-friendly abstraction)
- Webapp code stays platform-agnostic — no conditional imports
- Test injection via factory override parameter
- Capacitor and Tauri both expose platform APIs via window globals (perfect for detection)

**Key interfaces**:
```typescript
interface PlatformApi {
  openExternal(url: string): Promise<void>;
  writeClipboard(text: string): Promise<void>;
  syncLocale?(lang: string): Promise<void>;
  uploadLogs?(feedbackId: string): Promise<void>;
  isMobile: boolean;
  version: string;
}
```

**Validating tests**: `webapp/src/platform/__tests__/platform.test.ts` — 8 tests covering all implementations

---

## Dark-Only Theme via CSS Variables (2026-02-16, kaitu-feature-migration)

**Decision**: Ship exclusively dark mode. No light theme. No theme switcher. All design tokens defined as CSS custom properties in `app.css` under `@theme`.

**Why dark-only**:
- Reduces code complexity — no `dark:` Tailwind prefix, no theme toggle state
- No ThemeContext or theme store needed
- Faster development — design once, no light mode variants
- Product decision — kaitu brand is dark aesthetic

**Token architecture**:
- Base colors: `--color-bg-default`, `--color-bg-paper`, `--color-text-primary`
- Semantic status: `--color-success`, `--color-warning`, `--color-error`, `--color-info` (each with `-light`, `-dark`, `-bg`, `-border`, `-glow` variants)
- Component tokens: `--color-card-bg`, `--color-selected-border`, `--color-divider`
- All components use tokens via `bg-[--color-*]` pattern — zero hardcoded hex values in component files

**Migration note**: Replicated kaitu webapp's dark palette exactly (`theme.ts` dark object + `theme/colors.ts`). MUI `sx` props → Tailwind classes with CSS variables.

**Validating tests**: `webapp/src/components/__tests__/dark-theme.test.ts` — verifies CSS variables applied on body

---

## Global LoginDialog Modal Replaces Login Route (2026-02-16, kaitu-feature-migration)

**Decision**: Remove dedicated `/login` route. All authentication flows use a global `LoginDialog` modal component triggered on demand.

**Trigger sources**:
- App startup (AuthGuard): if no valid session, open dialog automatically
- Protected routes (LoginRequiredGuard): redirect → open dialog with context
- Feature pages (Purchase, Invite): click "login to continue" → open dialog with custom message

**State management**: `login-dialog.store.ts` Zustand store with `{ isOpen, trigger, message, open(), close() }`. On success, dialog closes and triggering page refreshes.

**Why modal over route**:
- No route navigation disruption — user stays on intended page
- Context-aware messaging ("Login to purchase" vs "Login to manage invites")
- Purchase page can show inline login form for unauthenticated users (same EmailLoginForm component)
- Mobile UX: modal feels more native than full-page route change

**Validating tests**: `webapp/src/components/__tests__/LoginDialog.test.tsx`, `webapp/src/components/__tests__/guards.test.tsx`

---

## Keep-Alive Tab Pattern for Tab Pages (2026-02-16, kaitu-feature-migration)

**Decision**: Tab pages (Dashboard, Purchase, Invite, Account) are mounted on first visit, then hidden (not unmounted) when switching tabs.

**Implementation**: `Layout.tsx` tracks mounted tabs in `useState`. Active tab rendered normally; inactive tabs use `visibility: hidden` + `position: absolute` CSS.

**Why keep-alive**:
- Preserves scroll position when switching tabs
- Maintains component state (form inputs, expanded sections)
- Reduces re-fetch on tab return (data stays loaded)
- Better perceived performance (instant tab switch, no loading spinner)

**Trade-off**: More memory usage (4 tab DOMs in memory). Acceptable for 4-tab app.

**Non-tab pages**: Sub-pages (`/devices`, `/issues`, etc.) use normal React Router `<Outlet />` — mount/unmount on navigate.

**Validating tests**: `webapp/src/components/__tests__/Layout.keepalive.test.ts`

---
